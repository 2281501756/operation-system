### 什么是并发如何理解并发

现代的cpu具有多个核可以同时跑多个线程，于是对于操作系统来说就有了并发的问题，并发也是十分好理解的如果带入状态机的视角


### 并发对高级语言为什么会存在问题

- 内存共享每一个线程之间都可以操作共享内存
- 编译器对高级语言的优化会导致一些指令发生重排，因为编译器是以单线程进行优化的
- 可见性的问题，对于cpu会同时执行尽可能多的指令然后返回如果不存在强依赖就会被cpu打乱顺序

```c
#include "thread.c"
#define N 100000

long sum = 0;

void Tsum()
{
    for (int i = 0; i < N; i++)
    {
        sum++;
    }
}

int main()
{
    create(Tsum);
    create(Tsum);
    join();
    printf("%ld\n", sum);
}
```
这段代码在o1的编译结果会生成100000在o2的编译结果是200000这就是编译器会并发程序产生的影响

### perterson协议

perterson协议是用来解决并发而发明的最早的通俗易懂的协议，在之前都没什么比较好的解决方法

执行流程：
- 每一个线程在需要执行的时候都会将自己的状态置为true
- 然后在公共内存的位置将对方的名字写入内存
- 如果对方状态为true并且公共内存的名字不是自己就会进入等待
- 执行完后将自己的状态置为false


这种精妙的流程能保证每一个状态都是线程安全的

```c
void TA()
{
    while (1)
    {
        x = 1;
        ture = B;
        while (y && ture == B);
        critical_section();
        x = 0;
    }
    
}

void TB()
{
    while (1)
    {
        y = 1;
        ture = A;
        while(x && ture == A);
        critical_section();
        y = 0;
    }
    
}
```
上述程序可以实现线程安全但是如何证明呢? 这个时候只能使用model chcker使用代码来画状态机将所有的状态计算出来













### 真实社会的并发程序

在现代的代码中无时不刻都离不开并发，因为现在不管是大厂的数据存储还是一些科研的运算量级都是十分大的，但是我们不需要使用很复杂的c或者c++去编写并发程序有了更好的方式去处理，比如我们现在的go语言，在语言层面避免操作系统线程切换带来的消耗和系统调用带来的时间消耗做到cpu高性能运行，以及使用channel这种协程之间的通信方式优化程序员的开发使得开发和维护成本很低，还有例如JavaScript这中脚本语言在浏览器上以单线程运行因为浏览器主要是操作dom和网络请求不会涉及到IO等操作，因此在浏览器上语言设计之初就是十分简单的，采用单线程事件循环十分有利于设计，同时为了优化callback的问题还推出了promise更加方便开发者进行开发，同时前端开发人员越来越多也让前端社区活跃

随后我们就发现了我们程序员无时无刻都离不开并发编程只是有大神帮助我们优化了这个过程，因此在现在作为一名程序员必须掌握一门现代的编程语言 （除了c和汇编之外的语言）

